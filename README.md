本项目为天津大学自动化学院2025年 人工智能概论 课程的期末大作业，由五人小组合作完成；项目目标为在yolov5s的基础上通过改进模型结构，对特定任务如障碍物检测与运动规划进行效果优化，实现具身智能感知；以展示pybullet仿真中的完整”感知——决策——行动“逻辑链条来体现课程对”具身智能“的要求。

---
### 一、项目分工：

**A.迟旭（模型构建、决策逻辑脚本与统筹协调）**：

> 1.负责基于yolov5s改进模型结构，增加了SEBlock模块与CBAM模块，并尝试修改参数和位置进行对比测试。
> 
> 2.编写onnx可视化脚本，进行模型结构可视化展示。
> 
> 3.修改common.py和yolo.py（导入自定义模块的方式），并编写模型构建集成测试
> 
> 4.为每个新模型编写yaml（配置文件）用于后续训练
> 
> 5.编写决策逻辑脚本，用于接收检测脚本的输入，输出结果给仿真脚本
> 
> 6.每天与所有人对接工作进展，审查代码，合并PR；写文档
> 
> 7.编写.gitignore文件用于版本控制


**B.张津亮（自定义数据集搭建）**

> 1.查看yolov5使用的官方数据集，从中筛选出一部分更贴近项目目标的数据用于训练模型
> 
> 2.在kaggle和huggingface上寻找更符合我们项目目标的障碍物检测型数据集
> 
> 3.拍摄校园内的日常照片，并使用labelimg等工具进行高质量标注
> 
> 4.整合以上数据成为自定义数据集，并分别编写格式转换脚本将其转换为yolo能够识别的类型。
> 
> 5.编写数据集配置文件用于后续训练


**C.李安琪（模型训练与结果可视化）**

> 1.使用官方模型加载预训练权重在自定义数据集上训练出一个基线模型，之后的改进都与之对比
> 
> 2.使用自定义数据集配置文件与自定义模型配置文件在随机初始化权重的条件下进行训练，训练出新的不同模型
> 
> 3.编写脚本将训练结果转换为可视化对比图表进行统计分析
> 
> 4.实时监控训练过程，编写模型对比分析文档；进行超参数调优


**D.高鸣邦（检测脚本）

> 1.在yolov5官方的检测脚本的基础上编写能够获取真实图像输入、真实视频输入和能从pybullet的虚拟相机获取图像输入，并可以使用我们改进之后的模型权重文件的脚本，输出特定的检测结果
> 
> 2.辅助PPT制作与文档编写


**E.刘竞聪（仿真脚本、联调脚本与PPT制作）**

> 1.编写pybullet仿真脚本，实现对仿真模拟小车的控制和仿真环境障碍物搭建
> 
> 2.编写联调主程序，调用检测脚本、决策逻辑脚本和仿真脚本，实现封装演示仿真效果
> 
> 3.为各个脚本编写单元测试，部分测试集成到脚本内部
> 
> 4.制作PPT用于汇报演示

### 二、技术选型过程

经过学习，我们决定采用yolov5s这一成熟、轻量化的模型进行改进。尝试增加SEBlock模块和CBAM模块，使用git进行版本管理,github作为代码托管平台。使用docker封装，便于其他人运行。

### 三、CNN原理相关

首先简单地再次讲一下CNN的原理：就是通过卷积操作提取特征；每个卷积核都有自己擅长识别的“模式”，如果图片这个区域符合它的“模式”，提取出来的特征图里这个区域的数值就会比较大（可以简单用黑板或PPT举个例子）。就像一张图片是由RGB三个通道叠加而成的，用不同的卷积核计算出来很多张特征图，每张特征图叠加起来就是新的图像，然后继续做卷积操作，会不断的把浅层识别出来的小的特征组合成更加完整的，有意义的特征，就像识别一只猫，可能先识别轮廓（圆弧、直线等等），再把这些特征组合成眼睛、耳朵等等，再组合成猫脸。归一化和激活函数是为了辅助模型学习得更好，例如激活函数就像一个“阀门”，关掉特征权重不够的结果，只保留比较明显的特征，这些都是为了让模型学习的效率更高。

那么yolov5s的结构是什么样子的呢？大家可以看这张图，是我用onnx文件导出到里进行模型结构可视化的结果。从宏观角度来讲，yolov5s可以分为三部分：backbone、neck、head：

**1. Backbone (骨干网络)：从像素到特征的“炼金术”**

- **作用通俗讲：** “Backbone是模型的‘眼睛’和‘初级大脑’。它的任务是把输入的原始图片（一堆像素点）转换成计算机更容易理解的‘特征’。这些特征就像是图片的关键信息摘要，比如哪里有边缘、哪里有角点、哪些区域的纹理比较特殊等等。”
    
- **YOLOv5s (v7.0) Backbone 结构解读 (结合yolov5s_v7_original_backbone.yaml或类似的标准结构)：**
    
    - **初始下采样 (Stem - 例如第0层 Conv):**
        
        - “一开始，模型会用一个比较大的卷积核（比如6x6，步长为2）对图片进行一次快速的‘粗略扫描’和‘尺寸压缩’。这就像我们看远处的东西，先眯起眼睛大概看一下轮廓。这一步会迅速减少数据量，并提取出最基础的边缘和纹理信息。”
            
        - **输出：** 尺寸减半的特征图，通道数增加 (例如32通道)。
            
    - **多级特征提取 (Stages - 例如后续的 Conv+C3 组合)：**
        
        - “接下来，Backbone会经历多个‘阶段’。每个阶段通常包含：”
            
            - 一个 Conv 层（步长为2）：继续“压缩”特征图的空间尺寸（让模型看得更“远”，关注更大范围的上下文），同时增加通道数（让模型从更多“角度”去理解特征）。
                
            - 若干个 C3 模块：这是YOLOv5的核心‘特征加工厂’。C3模块借鉴了CSPNet的思想，结构比较精巧，它内部有很多小的卷积和Bottleneck（瓶颈）结构。它的好处是能在不大幅增加计算量的前提下，深度挖掘和提炼当前尺度的特征，并且让信息在网络中流动更顺畅，学习效率更高。”
                
        - **特征的层级性：** “经过Backbone的层层处理，我们会得到不同‘深度’的特征图：”
            
            - **P3 (例如Backbone中层4的C3输出):** 尺寸相对较大 (原图1/8)，通道数适中 (例如128)。它保留了较多的**空间细节和位置信息**，对检测小目标很有帮助。
                
            - **P4 (例如Backbone中层6的C3输出):** 尺寸中等 (原图1/16)，通道数较多 (例如256)。它在细节和语义信息之间取得了平衡。
                
            - **P5 (例如Backbone中层9的SPPF输出):** 尺寸最小 (原图1/32)，通道数最多 (例如512)。它包含了最丰富的**高级语义信息**（比如“这是一个物体的整体概念”），对检测大目标和理解场景上下文很有帮助。
                
    - **SPPF模块 (在Backbone末端)：**
        
        - “在Backbone的最后，通常会有一个SPPF模块。你可以把它想象成给模型装上了‘广角镜’和‘变焦镜’的组合。它通过不同大小的池化操作，让模型能同时关注到不同感受野的信息，把局部细节和全局上下文都‘看’到，这对于识别不同大小的物体非常有帮助。”
            
- **我们对Backbone的初步理解和思考 (引出你们的改进)：**
    
    - “我们认识到，Backbone提取的特征质量直接决定了后续检测的上限。虽然YOLOv5s的Backbone已经很高效，但我们思考，在提取这些多尺度特征的过程中，是否能让模型更‘智能’地判断哪些特征通道对我们的特定障碍物更重要呢？”
        

**2. Neck (颈部网络 - FPN+PAN)：特征的“信息高速公路”与“融合中心”**

- **作用通俗讲：** “Backbone输出了好几份不同‘清晰度’和‘理解深度’的‘地图’（P3, P4, P5特征图）。Neck部分就像一个‘信息枢纽’，它的任务是把这些地图的优点结合起来，制作出几份‘超级地图’，既有高层地图的‘战略眼光’（语义信息），又有低层地图的‘精确导航’（位置信息）。”
    
- **YOLOv5s (v7.0) Neck 结构解读：**
    
    - **FPN (Feature Pyramid Network - 自顶向下)：**
        
        - “首先，Neck会把Backbone最深层、语义最丰富的P5特征图，通过‘上采样’（Upsample，把小图放大）的方式，逐层和P4、P3特征图进行‘信息共享’（通过Concat拼接，然后用C3模块进一步融合处理）。”
            
        - “这就好比，一个经验丰富的老侦察兵（P5）把他的‘大局观’传授给在前线观察细节的新兵（P3, P4），让新兵也能理解更宏观的模式。”
            
        - **结果：** 生成了初步融合了高级语义信息的 P4_fused 和 P3_fused 特征图。
            
    - **PAN (Path Aggregation Network - 自底向上)：**
        
        - “仅仅从上往下传递信息还不够。PAN结构又增加了一条‘反向汇报’的路径。它会把刚刚在FPN中融合了语义信息的P3_fused特征图，通过‘下采样’（Conv，把大图缩小）的方式，再逐层和P4_fused、P5_fused（P5的融合版本）进行‘信息补充’。”
            
        - “这就好比，前线新兵（P3_fused）把他们观察到的最新、最精确的‘地面情况’（定位信息）汇报给后方的指挥官（P4_fused, P5_fused），让指挥官的决策更接地气。”
            
        - **结果：** 生成了最终用于检测的三个尺度的特征图：P3_detect_in, P4_detect_in, P5_detect_in。这三张图都充分融合了来自不同层级的语义和位置信息。
            
- **我们对Neck的思考 (引出你们的改进)：**
    
    - “Neck是特征融合的关键环节。我们认为，如果在这个阶段能进一步优化特征的表达，让模型更好地辨别和整合来自不同路径的有用信息，将直接惠及最终的检测头。”
        

**3. Head (检测头 - Detect层)：最终的“目标锁定与识别”**

- **作用通俗讲：** “Head部分就是‘侦察兵’最终掏出‘望远镜和目标识别器’进行精确打击的部分。它接收来自Neck的三份‘超级地图’（P3, P4, P5的最终融合特征），然后在每张地图上进行预测。”
    
- **YOLOv5s (v7.0) Head (Detect模块) 工作方式：**
    
    - “对于Neck传来的每一张特征图（例如P3_detect_in），Detect模块会用一个1x1的小卷积（可以看作是一个小型的全连接层）将特征图的每个‘格子点’（grid cell）转换成预测信息。”
        
    - **锚框 (Anchors) 的作用：** “在每个格子点上，模型会基于预设的几种不同形状和大小的‘锚框’（Anchors）来进行预测。这些锚框就像是预先画好的几个‘嫌疑框’。”
        
    - **预测内容：** “对于每个锚框，模型会预测：”
        
        1. **边界框调整：** 这个锚框需要向哪个方向移动多少、放大或缩小多少，才能正好框住物体 (box_loss与之相关)。
            
        2. **物体置信度：** 这个调整后的框里到底有没有我们要找的障碍物 (obj_loss与之相关)。
            
        3. **类别概率：** 如果有障碍物，它是我们定义的22个类别中的哪一个 (cls_loss与之相关)。
            
    - **多尺度预测：** “由于有P3, P4, P5三个尺度的输入，Detect层能在不同尺度上分别进行预测，这样就能同时检测到图片中的小、中、大各种尺寸的障碍物了。”
        
- **NMS (非极大值抑制)：** “模型可能会对同一个物体产生多个重叠的预测框。NMS就像一个‘裁判’，它会根据置信度和重叠程度，把多余的框去掉，只保留最准的那个。” (这通常在Detect模块之后，在general.py中实现)

---


**二、我们的模型修改：给“侦察兵”装上更敏锐的“感官” (注意力机制)**

“基于对YOLOv5s工作原理的理解，我们团队的核心改进集中在引入和优化‘注意力机制’，目标是让模型在复杂的视觉环境中能更有效地聚焦于关键信息，从而提升障碍物检测的性能。”

**1. 引入SEBlock (Squeeze-and-Excitation Block)**

- **我的工作与理解 
    
    - **为什么引入SEBlock：** “我们首先尝试了SEBlock。如前所述，CNN的每一层会产生很多特征通道，每个通道代表一种学到的模式。但并非所有通道在所有情况下都同等重要。SEBlock的核心思想就是让网络**学会判断哪些特征通道更重要，并给它们更高的权重。**”
        
    - **通俗原理：** （待写）
        
        - “‘Squeeze’操作：通过全局平均池化，将每个通道的特征图压缩成一个数字，代表这个通道的‘整体激活度’。”
            
        - “‘Excitation’操作：通过两个全连接层（我们用1x1卷积实现）学习这些通道激活度之间的关系，为每个通道生成一个0到1之间的‘重要性得分’或‘注意力权重’。”
            
        - “‘Scale’操作：将这些权重乘回到原始的特征通道上，实现对重要通道的增强和次要通道的抑制。”
            
    - **我的具体实现：**
        
        - “我负责在我们自定义的common.py中编写了SEBlock的PyTorch模块代码。” (可以展示你写的SEBlock类的核心__init__和forward代码片段，并解释输入channels_from_yaml_arg0和ratio参数的意义)
            
        - “然后，我通过修改模型的.yaml配置文件，将SEBlock插入到了网络的不同位置进行实验。例如，我们尝试了在Backbone的每个C3模块之后加入SEBlock，也尝试了在Neck部分的关键特征融合节点（C3模块之后）加入SEBlock。” (可以展示一个YAML修改片段，高亮SEBlock的插入)
            
        - “我们还对SEBlock的reduction_ratio (r) 参数进行了实验，例如r=8, 16, 32，以观察不同压缩比对性能和模型复杂度的影响。”
            
    - **预期与实际效果 (结合C同学的实验结果)：**
        
        - “我们预期SEBlock能够帮助模型更聚焦于与障碍物相关的特征，从而提升检测精度。”
            
        - “(展示C同学的对比表格/图表) 实验结果显示，例如，在Neck部分加入SEBlock (r=16) 的版本，相较于基线模型，在我们的自定义数据集上，mAP@0.5提升了X%，mAP@0.5:0.95提升了Y%，而参数量仅增加了Z。这初步验证了SEBlock在我们任务上的有效性。” (用真实数据替换X, Y, Z)
            

**2. 引入CBAM (Convolutional Block Attention Module)**

- **我的工作与理解
    
    - **为什么引入CBAM：** “在SEBlock只关注通道维度的基础上，我们进一步探索了CBAM。CBAM的优势在于它**同时引入了通道注意力和空间注意力**，不仅告诉模型‘关注哪些特征类型（通道）’，还告诉模型‘关注图像的哪些区域（空间）’。”
        
    - **通俗原理：** (回顾“频道调音师”+“聚光灯操作员”比喻)
        
        - **通道注意力模块 (CAM)：** “CBAM的CAM与SEBlock类似，但它同时使用了平均池化和最大池化来捕捉更丰富的通道统计信息，然后通过一个共享的MLP（多层感知机，用1x1卷积实现）来生成通道权重。”
            
        - **空间注意力模块 (SAM)：** “在通道权重被应用之后，SAM开始工作。它会沿着特征图的通道维度进行平均池化和最大池化，得到两张代表空间信息的特征图。然后将这两张图拼接起来，通过一个卷积层（通常是7x7）来学习一个空间注意力图，这个图会高亮显示那些对任务重要的空间区域。”
            
        - **顺序应用：** “CBAM将CAM和SAM顺序应用，实现对特征在通道和空间维度上的双重增强。”
            
    - **我的具体实现：**
        
        - “我同样在自定义的common.py中编写了CBAM模块及其子模块ChannelAttention和SpatialAttention的PyTorch代码。” (可以展示CBAM类或其子模块的核心代码片段，并解释channels_from_yaml_arg0, ratio, kernel_size参数)
            
        - “我们主要实验了将CBAM放置在Neck部分，替代之前SEBlock的位置，或者与SEBlock进行组合（如果时间允许）。” (展示YAML修改片段)
            
    - **预期与实际效果 (结合C同学的实验结果)：**
        
        - “我们期望CBAM能够通过其更全面的注意力机制，在SEBlock的基础上进一步提升模型的性能，尤其是在目标的精确定位和复杂背景下的识别能力。”
            
        - “(展示C同学的对比表格/图表，包含CBAM版本的结果) 实验结果显示，CBAM版本模型在...(例如mAP@0.5:0.95上表现突出，或者在某些特定难检测类别上效果更好)...。虽然CBAM的参数量和计算量比SEBlock略高，但...(根据结果说明是否值得)。”
            

**3. YAML配置与模型构建的理解与实践**

- **我的工作与理解 ：**
    
    - “为了实现这些网络结构的修改，我深入学习了YOLOv5通过YAML配置文件来定义模型架构的方式。”
        
    - **关键点：**
        
        - “[from, number, module, args] 这四个参数的精确含义和相互关系，特别是from索引在插入/删除模块后的正确更新。”
            
        - “depth_multiple和width_multiple如何影响实际的网络深度和通道数。”
            
        - “自定义模块（如SEBlock, CBAM）的__init__方法参数如何与YAML中args列表进行对应，特别是parse_model对已知模块和未知模块的参数传递方式的差异。”
            
    - **实践：** “我编写并使用了test_model_build.py脚本来频繁验证我修改后的YAML文件是否能够成功构建模型并通过前向传播，这帮助我们快速定位和修复了许多由于索引错误或参数不匹配导致的问题。”
        
    - “我还通过sys.path的修改，实现了在不‘污染’原始YOLOv5源码的情况下，让模型构建过程优先加载我们自定义的common.py文件，这保证了我们代码的整洁性和可管理性。”
        

---
### 四、训练过程与具身智能仿真模拟

在项目推进过程中，我们发现在真实硬件上进行开发遇到了很多问题，例如Realsense系列的SDK使用，机器人运动控制等等难度较高，因此我们将目标转向先用pybullet实现仿真模拟；同时负责数据与训练的同学通过修改配置文件、重新训练，让自定义模型在原有的真实图像输入检测能力下降较少的条件下提高了对pybullet内置障碍物的检测能力，以下是我们100个epoch下不同模型的数据对比，通过100个epoch下的训练我们能够初步筛选出具有提升潜力的模型，进行进一步训练，最终得到的权重将用于检测脚本。

训练工作基本结束后，我们开始 检测脚本、决策逻辑脚本与仿真模拟脚本 三项同步推进，并开始编写联调主程序

联调成果：可以实现小车在pybullet环境内进行运动避障和实时环境检测。

---
### 五、项目复现（写给读者）

1.如果你不使用docker，并且想从头开始训练，首先请创建环境，然后按依赖文档中的内容安装依赖

```bash
conda create yolov5s_tju_ai_course -pytorch
```

```bash
pip install -r requirements.txt
```

2.假设你已下载并准备使用我们准备好的数据集，请进行数据格式转换

```bash
python cocotoyolo.py
```

3.完成数据格式转换之后，开始训练

```bash
python train.py
```

4.训练结果将会自动保存在相关目录下，接下来运行

```bash
python val.py
```

5.使用得到的`best.pt`运行主程序（需要自己改路径）

```bash
python main_simulation_loop.py
```

6.可以看到屏幕上打开pybullet界面，小车开始运动

---

**如果你使用docker，请运行**（等docker file写完的）

### 六、我们遇到过的问题：

1.基线模型在35个epoch就已经表现良好：使用了预训练权重、并且数据集当时尚未完善，只有官方数据集

2.有三次自定义模型实验数据重合严重：训练的同学忘记改配置文件路径，得到了几次无效的训练结果

3.部分自定义模型在100个epoch之后表现不佳：一方面是数据集质量还不够高，另一方面是因为预训练权重因为模型结构更改后无法匹配，只能默认从随机初始化开始训练，效率较低

4.模型构建的问题：最理想的方式其实是不对官方原生的common.py做侵入式修改，但我们改了，比较直观方便，容易通过构建测试

5.不同协作者的yolov5版本不同：用git看版本信息，找commit hash同步，或直接复制一个人的项目文件（最简单粗暴的同步方式）。

6.复杂冲突无法合并PR：没啥说的，耐心地看、改。

7.联调初期遇到的问题：大部分是因为不同脚本之间用到的工具来源的版本不一致，有些和yolo有关，有些和pybullet有关，同步版本，详细核对数据接口就好了。

### 未来的目标：

应用于实际的具身智能场景，比如智能驾驶之类，或者先从简单的来：给电控小车加一个摄像头，用来进行目标检测，智能避障。

---
### 结语：

感谢各位队友、老师，感谢Gemini和Deep Seek。

一周之内我一个人和Gemini 2.5 pro的对话量就已经达到了恐怖的150wtoken，聊崩了三个对话；科技改变生活，根据Gemini自己评估，如果没有ai帮助，我们这个难度的大作业可能要写8~16周才能完成，而现在我们作为自动化专业的学生，在短期内掌握这么多工具和技能，走完了一遍完整的技术选型、模型训练、实际应用的过程其实也是一件挺不容易的事儿。谢谢你们！深度学习真的很好玩。


---
#### 附录：

每个人的代码贡献：
