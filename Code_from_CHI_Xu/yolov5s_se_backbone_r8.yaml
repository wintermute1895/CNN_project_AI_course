# yolov5s_se_backbone_r8.yaml
# 基于你提供的 yolov5s_with_se.yaml (Backbone中已有SEBlock)
# 目标: 仅修改 Backbone 中 SEBlock 的 reduction_ratio (r) 参数为 8。
#       r=8 意味着SEBlock中间层的通道数更多 (c1 // 8)，模型复杂度略微增加，
#       期望可能捕获更细致的通道依赖关系。

# Parameters (与你原文件一致)
nc: 22
depth_multiple: 0.33
width_multiple: 0.50
anchors:
  - [10, 13, 16, 30, 33, 23]
  - [30, 61, 62, 45, 59, 119]
  - [116, 90, 156, 198, 373, 326]

# YOLOv5 v6.0 backbone (SEBlock 的 r 参数修改为 8)
# 每一行的注释会标出该层输出的实际通道数 (考虑width_multiple=0.5)
backbone:                               # Layer | Output Channels (Actual)
  [[-1, 1, Conv, [64, 6, 2, 2]],       # 0     | 32
   [-1, 1, Conv, [128, 3, 2]],      # 1     | 64
   [-1, 3, C3, [128]],               # 2     | 64
   # SEBlock: 输入通道64, reduction_ratio r=8
   [-1, 1, SEBlock, [64, 8]],        # 3     | 64  <-- r 修改为 8
   [-1, 1, Conv, [256, 3, 2]],      # 4     | 128
   [-1, 6, C3, [256]],               # 5     | 128
   # SEBlock: 输入通道128, reduction_ratio r=8
   [-1, 1, SEBlock, [128, 8]],       # 6     | 128 <-- r 修改为 8
   [-1, 1, Conv, [512, 3, 2]],      # 7     | 256
   [-1, 9, C3, [512]],               # 8     | 256
   # SEBlock: 输入通道256, reduction_ratio r=8
   [-1, 1, SEBlock, [256, 8]],       # 9     | 256 <-- r 修改为 8
   [-1, 1, Conv, [1024, 3, 2]],     # 10    | 512
   [-1, 3, C3, [1024]],              # 11    | 512
   [-1, 1, SPPF, [1024, 5]],       # 12    | 512
  ]

# YOLOv5 v6.0 head (与你原文件一致，但请务必确认from索引的正确性！)
# 这一部分的from索引必须与上面backbone最终的层序号和通道数严格对应。
# 如果你上面的backbone的层序号或输出通道因为某种原因与你之前测试通过的版本不一致，这里会出错。
head: [
    [-1, 1, Conv, [512, 1, 1]],      # 13, from L12
    [-1, 1, nn.Upsample, [None, 2, "nearest"]], # 14
    # 假设P4_SE来自层9 (你需要确认你SEBlock后的层9输出是你期望的P4级别特征)
    [[-1, 9], 1, Concat, [1]],       # 15
    [-1, 3, C3, [512, False]],       # 16

    [-1, 1, Conv, [256, 1, 1]],      # 17, from L16
    [-1, 1, nn.Upsample, [None, 2, "nearest"]], # 18
    # 假设P3_SE来自层6 (你需要确认你SEBlock后的层6输出是你期望的P3级别特征)
    [[-1, 6], 1, Concat, [1]],       # 19
    [-1, 3, C3, [256, False]],       # 20 (P3_detect_in)

    [-1, 1, Conv, [256, 3, 2]],      # 21, from L20
    # 假设这里的 P4_fused 来自层16 (或层17 Conv的输入)
    [[-1, 16], 1, Concat, [1]],      # 22 (这里假设concat的是L21的输出和L16的输出)
    [-1, 3, C3, [512, False]],       # 23 (P4_detect_in)

    [-1, 1, Conv, [512, 3, 2]],      # 24, from L23
    # 假设这里的 P5_neck_in 来自层13 (或层14 Upsample的输入)
    [[-1, 13], 1, Concat, [1]],      # 25 (这里假设concat的是L24的输出和L13的输出)
    [-1, 3, C3, [1024, False]],      # 26 (P5_detect_in)

    [[20, 23, 26], 1, Detect, [nc, anchors]], # 27
  ]